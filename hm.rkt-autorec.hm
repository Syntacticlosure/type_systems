#lang racket
(require "adt.rkt")

(adt.together
 (adt tm #:description "term"
      (zero? [e tm?])
      (+ [e1 tm?] [e2 tm?])
      (* [e1 tm?] [e2 tm?])
      (let [x symbol?][e tm?][body tm?])
      (fix [e tm?])
      (lit [c any/c]) ;; constant
      (var [n symbol?]) ;; x
      (lam [x symbol?] [body tm?]) ;; λx.e
      (app [f tm?] [arg tm?]) ;; t1 t2
      (if [test tm?] [then tm?] [else tm?])
      )
 (adt ty #:description "type"
      (var [n symbol?])
      (bool)
      (int)
      (-> [f ty?] [t ty?])
      (all [vars (listof symbol?)] [t ty?])))

(adt option
     (some [x any/c])
     (none))

;; Parsers and UnParsers

(define/contract gensym
  (-> symbol? symbol?)
  (let ([count 0])
    (λ (x)
      (begin0 (string->symbol (format "~a~a" x count))
              (set! count (add1 count))))))

(define/contract (tm.parse sexp)
  (-> any/c tm?)
  (define (parse-app apps init)
    (if (null? apps)
        init
        (parse-app (cdr apps) (tm.app init (tm.parse (car apps))))))
  (define (parse-let bds body)
    (if (null? bds)
        body
        (let* ([bd (car bds)]
               [bds* (cdr bds)]
               [x (first bd)]
               [e (second bd)])
          (tm.let x (tm.parse e) (parse-let bds* body)))))
  (match sexp
    [(? symbol? x) (tm.var x)]
    [`(zero? ,e) (tm.zero? (tm.parse e))]
    [`(+ ,t1 ,t2) (tm.+ (tm.parse t1) (tm.parse t2))]
    [`(* ,t1 ,t2) (tm.* (tm.parse t1) (tm.parse t2))]
    [`(fix ,e) (tm.fix (tm.parse e))]
    [`(let ,bds ,body) (parse-let bds (tm.parse body))]
    [`(if ,test ,then ,else) (tm.if (tm.parse test) (tm.parse then) (tm.parse else))]
    [`(λ (,x) ,e) (tm.lam x (tm.parse e))]
    [`(λ (,x ,rst ...) ,e) (tm.lam x (tm.parse `(λ ,rst ,e)))]
    [`(,t1 ,t2 ,t3 ...) ;; left associvity
     (parse-app `(,t2 ,@t3) (tm.parse t1))]
    [_ (tm.lit sexp)]))

(define/contract (tm.unparse tm)
  (-> tm? any/c)
  (define (unparse-lam tm vars)
    (match tm
      [(tm.lam x e) (unparse-lam e (cons x vars))]
      [e `(λ ,(reverse vars) ,(tm.unparse e))]))
  (define (unparse-app apps rhs)
    (match apps
      [(tm.app t1 t2) (unparse-app t1 (cons (tm.unparse t2) rhs))]
      [e (cons (tm.unparse e) rhs)]))
  (match tm
    [(tm.var x) x]
    [(tm.lit x) x]
    [(tm.lam x e) (unparse-lam e (list x))]
    [(tm.zero? e) `(zero? ,(tm.unparse e))]
    [(tm.app t1 t2) (unparse-app t1 (list (tm.unparse t2)))]
    [(tm.+ e1 e2) `(+ ,(tm.unparse e1) ,(tm.unparse e2))]
    [(tm.* e1 e2) `(* ,(tm.unparse e1) ,(tm.unparse e2))]
    [(tm.fix e) `(fix ,(tm.unparse e))]
    [(tm.let x e body) `(let ([,x ,(tm.unparse e)]) ,(tm.unparse body))]
    [(tm.if e1 e2 e3) `(if ,(tm.unparse e1) ,(tm.unparse e2) ,(tm.unparse e3))]))


(define/contract (ty.parse sexp)
  (-> any/c ty?)
  (match sexp
    [`bool (ty.bool)]
    [`int (ty.int)]
    [`(all ,vars ,T) (ty.all vars (ty.parse T))]
    [`(-> ,ty1 ,ty2) (ty.-> (ty.parse ty1) (ty.parse ty2))]
    [`(-> ,ty1 ,ty2 ,tyrst ...) (ty.-> (ty.parse ty1) (ty.parse `(-> ,ty2 ,@tyrst)))]
    [(? symbol? x) (ty.var x)]))

(define/contract (ty.unparse ty)
  (-> ty? any/c)
  (define (unparse-arr ty lhs)
    (match ty
      [(ty.-> f t) (unparse-arr t (cons (ty.unparse f) lhs))]
      [ty `(-> ,@(reverse lhs) ,(ty.unparse ty))]))
  (match ty
    [(ty.bool) `bool]
    [(ty.int) `int]
    [(ty.var n) n]
    [(ty.-> f t) (unparse-arr t (list (ty.unparse f)))]
    [(ty.all vars T) `(all ,vars ,(ty.unparse T))]))

;; type environments
(define ty.env? (hash/c symbol? ty?))

(define/contract (ty.env.ref env x)
  (-> ty.env? symbol? option?)
  (call/ec (λ (bk)
             (option.some (hash-ref env x (λ () (bk (option.none))))))))

(define/contract (ty.env.set env x ty)
  (-> ty.env? symbol? ty? ty.env?)
  (hash-set env x ty))

;; normalize
(define/contract (ty.nz ty env)
  (-> ty? ty.env? ty?)
  (match ty
    [(ty.var n) (match (ty.env.ref env n)
                  [(option.some t) (ty.nz t env)]
                  [(option.none) ty])]
    [(ty.-> f t) (ty.-> (ty.nz f env) (ty.nz t env))]
    [ty ty]))

;; weak normalize
(define/contract (ty.wnz ty env)
  (-> ty? ty.env? ty?)
  (match ty
    [(ty.var n) (match (ty.env.ref env n)
                  [(option.some t) (ty.wnz t env)]
                  [(option.none) ty])]
    [ty ty]))

(define/contract (ty.unifyerr ty1 ty2)
  (-> ty? ty? void?)
  (error (format "type error: cannot unify type ~a with type ~a"
                 (ty.unparse ty1)
                 (ty.unparse ty2))))

(define/contract (ty.unify ty1 ty2 env)
  (-> ty? ty? ty.env? ty.env?)
  (match* ((ty.wnz ty1 env) (ty.wnz ty2 env))
    [((ty.bool) (ty.bool)) env]
    [((ty.int) (ty.int)) env]
    [((ty.-> f1 t1) (ty.-> f2 t2)) (ty.unify f1 f2 (ty.unify t1 t2 env))]
    [((ty.var tvar) ty2) (ty.unifyv tvar ty2 env)]
    [(ty1 (ty.var tvar)) (ty.unifyv tvar ty1 env)]
    [(ty1 ty2) (ty.unifyerr ty1 ty2)]))

(define/contract (ty.unifyv tvar ty env)
  (-> symbol? ty? ty.env? ty.env?)
  (match ty
    [(ty.var (== tvar)) (ty.env.set env tvar ty)] ;; T == T
    [ty  ;; normalized ty
     (if (ty.occurs tvar ty env)
         (ty.unifyerr (ty.var tvar) ty)
         (ty.env.set env tvar ty))]))

(define/contract (ty.occurs tvar ty env)
  (-> symbol? ty? ty.env? boolean?)
  (match ty
    [(ty.-> f t) (or (ty.occurs tvar f env)
                     (ty.occurs tvar t env))]
    [(ty.var n) (match (ty.wnz ty env)
                  [(ty.var n) (eqv? tvar n)]
                  [ty (ty.occurs tvar ty env)])]
    [ty #f]))

(define/contract (ty.inst ty env)
  (-> ty? ty.env? ty?)
  (define (loop ht ty)
    (match (ty.wnz ty env)
      [(ty.var n) (define generic? (hash-ref ht n #f))
                  (if generic? generic? (ty.var n))]
      [(ty.-> f t) (ty.-> (loop ht f) (loop ht t))]
      [ty ty]))
  (match ty
    [(ty.all vars T) (loop (for/hasheq ([v vars])
                             (values v (ty.var (gensym 'tvar)))) T)]
    [ty ty]))

;; tenv: typing context
;; tcenv: typing constraints
(define/contract (typecheck tm tenv tcenv)
  (-> tm? ty.env? ty.env? (list/c ty? ty.env?))
  (match tm
    [(tm.var n) (match (ty.env.ref tenv n)
                  [(option.some ty) (list ty tcenv)]
                  [(option.none) (error (format "variable not found: ~a" n))])]
    [(tm.lam x e) (define tvar (ty.var (gensym 'tvar)))
                  (match-define (list result-ty tcenv1) (typecheck e (ty.env.set tenv x tvar) tcenv))
                  (list (ty.-> tvar result-ty) tcenv1)]
    [(tm.app t1 t2) (match-define (list ty1 tcenv1) (typecheck t1 tenv tcenv))
                    (match-define (list ty2 tcenv2) (typecheck t2 tenv tcenv1))
                    (define resultvar (ty.var (gensym 'tvar)))
                    (list resultvar (ty.unify ty1 (ty.-> ty2 resultvar) tcenv2))]
    [(or (tm.* e1 e2) (tm.+ e1 e2))
     (match-define (list ty1 tcenv1) (typecheck e1 tenv tcenv))
     (match-define (list ty2 tcenv2) (typecheck e2 tenv tcenv1))
     (list (ty.int) (ty.unify ty1 (ty.int) (ty.unify ty2 (ty.int) tcenv2)))]
    [(tm.zero? e)
     (match-define (list ty tcenv1) (typecheck e tenv tcenv))
     (list (ty.bool) (ty.unify ty (ty.int) tcenv1))]
    [(tm.fix e)
     (match-define (list ty tcenv1) (typecheck e tenv tcenv))
     (define tvar (ty.var (gensym 'tvar)))
     (list tvar (ty.unify ty (ty.-> tvar tvar) tcenv1))]
    [(tm.if e1 e2 e3) (match-define (list ty1 tcenv1) (typecheck e1 tenv tcenv))
                      (match-define (list ty2 tcenv2) (typecheck e2 tenv tcenv1))
                      (match-define (list ty3 tcenv3) (typecheck e3 tenv tcenv2))
                      (list ty2 (ty.unify ty1 (ty.bool) (ty.unify ty2 ty3 tcenv3)))]
    [(tm.lit (? integer?)) (list (ty.int) tcenv)]
    [(tm.lit (? boolean?)) (list (ty.bool) tcenv)]))

(define/contract (tyck sexp)
  (-> any/c any/c)
  (match-define (list ty tcenv) (typecheck (tm.parse sexp) (hasheq) (hasheq)))
  (ty.unparse (ty.nz ty tcenv)))

(tyck `(λ (x) x))
(tyck `(λ (f x) (f x)))
(tyck `(λ (x) (+ x 1)))
(tyck `(λ (g) (g g)))

(tyck `(fix (λ (self x)  (if (zero? x) 1 (* x (self (+ x -1)))))))
(tyck `(λ (x) (if #t x 1)))